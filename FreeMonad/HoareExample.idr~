module Main

import Free
import HoareState
import Environment

import Data.Vect
import Data.So

%language ElabReflection

%access export

data Except a = Result a
              | E String
              
implementation Functor Except where 
  map f (Result a) = Result (f a)
  map f (E msg   ) = E msg
  
implementation Applicative Except where 
  pure = Result
  (Result f) <*> g = map f g
  (E msg   ) <*> g = E msg
  
implementation Monad Except where 
  (Result x) >>= g = g x
  (E msg   ) >>= _ = E msg

getFS : IO FSTree
getFS = pure $ FSLeaf (MkFileInfo "file.txt" 
    (MkFileMD F [[True, True, True], [True, True, True], [True, True, True]] (U "cas" "root"))
  )

||| assert precondition
||| We'll just pretend this exists for now
assertPre : (i : s) -> HoareState s a p q -> IO (Except (p i))
assertPre = ?assertPre

exec : (init : FSTree) -> HoareState FSTree a p q -> IO (Except ((a, FSTree) >< q init))
exec init st = do 
  cPre <- assertPre init st
  case cPre of 
    (Result prf) => 
      let (s ** prf) = 
        hrun (init ** prf) st in
      pure (Result (s ** prf))
    (E msg)    => pure $ E msg




